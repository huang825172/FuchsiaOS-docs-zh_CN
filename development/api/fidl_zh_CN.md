# FIDL API 可读性规范

[TOC]

## 注意事项

这一部分描述了使用 [Fuchsia 接口定义语言](https://fuchsia.googlesource.com/docs/+/master/development/languages/fidl/README.md) 定义接口所需注意的事项。

### 协议不属于对象

FIDL 是为定义进程间通信协议设计的语言。尽管其语法形似面向对象接口设计，其设计其实更加侧重于网络协议而非对象系统。例如，要设计高质量的接口系统，你必须考虑到带宽，延迟，以及流式控制。你还需要考虑到：接口并不只是分组的操作。接口还包含对于请求的先入先出系统，而将接口进行拆分意味着，对于两个不同接口的请求，可以根据接口之间的关系进行重新排序。

### 注意类型

关于接口设计，一个很好的切入点是接口所使用数据结构的设计。例如，一个关于网络的 FIDL 协议很可能会包含很多类型的 IP 地址结构，而一个关于图像处理的 FIDL 协议将包含很多几何学相关的概念。类型名称应该让使用者对协议控制的内容和可能的结构一目了然。

### 语言中立性

很多不同的语言都有其对应的 FIDL 后端。你应该避免你的 FIDL 定义过分侧重于某一种目标语言。因为在项目发展的过程中，你的 FIDL 协议可能会被许多不同的语言所使用，甚至可能包括现在还未支持的语言。 FIDL 是将 Fuchsia 系统粘合在一起的胶水，同时也为系统提供了不同语言和运行时的支持。如果你过分侧重于你所喜爱的语言，将忽视这一核心价值取向。

## 命名

```
给猫起名字是一件重要而困难的事情，
这不只是你在假日所进行的游戏；
    --- T.S. Eliot
```

FIDL 中的命名将被用于生成每一种目标语言中的定义。有一些目标语言是大小写敏感的，有一些目标语言对于特定元语有特定解读。例如，在 Go 语言中，定义对象的名称首字母是否大写决定了其可见性。因此，许多目标语言的后端会将你所定义的名称进行转换，以适应其目标语言。这一部分所讲述的命名规范，平衡了了 FIDL 源码的可读性，每一种目标语言中的可用性，和在不同目标语言之间的适应性。

避免使用常用的保留字，比如 `goto`。目标语言的后端会将保留字标识符转换为非保留字标识符，但这些转换将会降低其在目标语言中的可用性。避免使用常用的保留字将会降低这些转换发生的概率。

当一些 FIDL 关键字同时也是目标语言保留字时（例如 C 和 C++ 中的 `struct`），其应该被避免使用。其他的 FIDL 关键字，尤其是 `request` 和 `handle`，具有很好的描述性并可以被使用。

命名不应该包含前后缀下划线。前后缀下划线在某些目标语言中有着语法含义（例如，前缀下划线在 Dart 语言中具有控制可见性的作用），在另一些语言中则具有控制性作用（例如，后缀下划线在 C++ 中有控制作用，并用于成员变量）。
另外，FIDL 编译器使用前后缀下划线来避免标识符重复。

### 库命名

库的名称在标识符中是一个独立的片段。库的名称应该形如命名空间的引用。每一个组成名称的部分都应该由小写字母组成，并遵循此正则表达式 `[a-z][a-z0-9]*`。

我们使用严格的命名规范，因为不同的目标语言对于命名空间、库或者包有着不同的命名限制。我们使用了这些规则的最小子集来保证 FIDL 能够适应目前的，以及未来有可能支持的目标语言。

优先使用表明功能的命名（例如 `fuchsia.media`）而不是产品名称或代码命名（例如 `fuchsia.amber` 或者 `fuchsia.mozart`）。产品命名一般用于代码属于 Fuchsia 之外的其他实体，而该接口只用于该产品的时候。例如，`fuchsia.cobalt` 比 `fuchsia.metrics` 更加适合作为 Cobalt 的接口名。因为其他的 metrics 实现（例如 Firebase）将不会命名重名的接口。

Fuchsia 源码书中的 FIDL 库定义必须在 `fuchsia` 顶级命名空间下（例如 `fuchsia.ui`），除非（a）库定义了 FIDL 语言自身的组成部分或者测试组件，在这种情况下，顶级命名空间必须是 `fidl`，或者（b）这个库只用于外部测试，不被包含在 SDK 或生产构建中，在这种情况下，顶级命名空间必须为 `test`。

避免包含超过两个点的库名（例如 `fuchsia.foo.bar.baz`）。在一些情况下，使用三个点是允许的，但这样的情况十分稀有。你只应该在具有特殊原因的情况下选择使用超过两个点。

应尽量在库名中引入特定库名称来声明库的依赖关系，而对于反向依赖的库名则应该尽量避免出现。例如 `fuchsia.foo.bar` 很可能依赖于 `fuchsia.foo`，但 `fuchsia.foo` 不应该依赖于 `fuchsia.foo.bar`。这种模式具有很好的可拓展性。因为在项目开发过程中，我们可以增加更多具有特定库名名称的库。具有非特定名称的库数量有限。Having libraries with
less specific names know about libraries with more specific names privileges the
current status quo relative to the future.

库名不应该包含下列部分： `common`，`service`，`util`，`base`，`f<letter>l`，`zx<word>`。避免这些（或其他）无意义的名字。如果你希望在另一个库中引用 `fuchsia.foo.bar` 和 `fuchsia.foo.baz` 的一些共同部分，考虑将他们定义在 `fuchsia.foo` 中而不是在 `fuchsia.foo.common` 中。

### 顶级命名

避免与库名重复的命名。例如，在 `fuchsia.process` 库中，一个启动进程的接口应该被明明为 `Launcher` 而不是 `ProcessLauncher`。因为名称 `process` 已经在库名称中出现了。在所有的目标语言中，顶级命名都以库名称为界。

### 原始别名

原始别名的命名必须使用 `lower_snake_case`。

```
using vaddr = uint64;
```

常量名不能够与所附属的库崇明。在所有的目标语言中，常量名都以其附属的库为界。

### 接口

接口命名必须遵循 `UpperCamelCase` 且必须为名词性表达式。典型的，接口以代表一种行为的名词命名。例如 `AudioRenderer` 是一个表明了该接口与音频渲染相关的名词。类似的，`Launcher` 是一个表明了该接口与启动操作相关的名词，而相关的具体内容则于其实现有关。

接口可以使用面向对象的设计方式进行命名。例如，`fuchsia.font.Provider` 使用了 `provider` 后缀，它表明接口将提供字体（而非自身代表字体）。类似的，`fuchsia.tracing.Controller` 使用了 `controller` 后缀，表明接口控制了轨迹系统（而不是自身代表轨迹）。

名称 `Manager` 可能会用于一个包含多样内容的接口。例如， `fuchsia.power.Manager`。然而，需要留意 "manager" 接口通常会包含许多松散联系的功能。它们最好能够被划分为多个接口。

接口命名不应该包括 "service."。所有的接口都在定义服务，这个成分是没有意义的。例如 `fuchsia.net.oldhttp.HttpService` 有两个不符合本规范的内容。首先，"http" 前缀与包含它的库名重复了。第二，"service" 后缀不应该被使用。注意在后续的 FIDL 库中，`fuchsia.net.http` 已经省略了无用的接口。

### 方法

方法命名必须采用 `UpperCamelCase` 并且必须使用动词性结构。例如， `GetBatteryStatus` 和 `CreateSession` 都是表明了方法行为的动词性结构。

"listener" 和 "observer" 接口中，在特定事件发生时被调用的方法应该加上 `On` 前缀，并使用过去式来表述发生的事件。例如， `ViewContainerListener` 接口有一个名为 `OnChildAttached` 的方法。类似的，事件（例如服务端自发发送给客户端的消息）应该加上 `On` 前缀，并以过去式表述发生的事件。例如， `AudioCapturer` 接口包含一个名为 `OnPacketCaptured` 的事件。

### 参数

参数命名必须遵循 `lower_snake_case`。

### 结构体和联合体

结构体和联合体的命名必须遵循 `UpperCamelCase` 而且必须是名词性结构。
例如， `Point` 是一个定义了空间中点位置的结构体，`KeyboardEvent` 是一个定义了键盘相关事件的结构体。

### 结构体和联合体的成员

结构体和联合体成员的命名必须遵循 `lower_snake_case`。实际开发时，成员使用单个词的命名是更好的选择，因为这样提供了最广泛的目标语言适应性。然而，如果一个词表意不明的话，多个单词组成的命名也是可以接受的。

成员变量的命名不应该重复其所属结构（或库）的名称。例如，包含了事件发送时间的 `KeyboardEvent` 成员应该被命名为 `time` 而不是 `event_time`，因为 `event` 已经在其所属的结构名中出现过了。在所有的目标语言中，成员名都以其所属的结构为界。

### 枚举类型

枚举类型的命名必须遵循 `UpperCamelCase` 并且必须为名词性结构。例如， `PixelFormat` 是一个定义了图像中的颜色如何编码的枚举类型。

### 枚举类型成员

枚举类型成员必须准寻 `ALL_CAPS_SNAKE_CASE` 。

枚举类型成员名必须不与其所属的结构（或库）所重复。例如，枚举类型 `PixelFormat` 的成员应该被命名为 `ARGB` 而不是 `PIXEL_FORMAT_ARGB` 。因为 `PIXEL_FORMAT` 已经在其所属的结构名中出现。在所有的目标语言中，枚举类型的成员名都以其所属的结构为界。